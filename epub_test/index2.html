<html>
    <head>
        <style>
            #content {
                display: none;
            }
            #prev {
                display: block;
                position: fixed;
                top: 0;
                left: 0;
                width: 5vw;
                height: 100vh;
                background-color: red;
            }
            #next {
                display: block;
                position: fixed;
                top: 0;
                right: 0;
                width: 5vw;
                height: 100vh;
                background-color: blue;
            }
            #page {
                border: 1px solid red;
                padding: 2em;
                margin: 5vw;
                width: 50vw;
                font-size: 1.2em;
            }
        </style>
        <script>
            function getData(callback) {
                var xhttp = new XMLHttpRequest()
                xhttp.onreadystatechange = function() {
                    if (this.readyState == 4 && this.status == 200 && this.responseText.length > 0) {
                        extractContents(this.responseText)
                        //findPages()
                        if (callback != null) callback()
                    }
                }
                xhttp.open("GET", "part0005.html", true)
                xhttp.send()
            }
            function extractContents(data) {
                let parser = new DOMParser()
                let doc = parser.parseFromString(data, "text/html")
                let content = doc.querySelectorAll("body > *")
                var contentDiv = document.getElementById("content")
                for (var i = 0; i < content.length; i++) { 
                    contentDiv.appendChild(content[i])
                }
            }
            /*function findPages() {
                var pages = []
                var documentEnd = false
                var currentPosition = 0
                pages.push(currentPosition)
                while (! documentEnd) {
                    var result = loadPage(currentPosition, pages.length)
                    currentPosition = result.endPosition
                    pages.push(currentPosition)
                    documentEnd = result.documentEnd
                }
                clearPage()
                console.log(pages)
                document.pages = pages
                document.currentPage = 0
                fillPage(document.pages[0], document.pages[1], false)
            }*/

            function previousPage() {
                if (document.currentPage > 0) {
                    document.currentPage = document.currentPage - 1
                    copyTextToPage(getPositions(), document.pages[document.currentPage], document.pages[document.currentPage + 1])
                } else {
                    console.log("beginning of doc")
                }
            }

            function nextPage() {
                // see if there is a next page
                if (document.currentPage < document.pages.length - 2) {
                    document.currentPage = document.currentPage + 1
                    copyTextToPage(getPositions(), document.pages[document.currentPage], document.pages[document.currentPage + 1])
                } else {
                    console.log("end of doc")
                }
            }

            /*function loadPage(startPosition, pn) {
                //var jump = 10
                var endPosition = startPosition + 100
                var previousEndPosition = null

                clearPage()
                var documentEnd = false
                var returnedEnd = null
                var pageToLog = 1
                while ((! scrollNecessary()) && (! documentEnd) && (endPosition != previousEndPosition)) {
                    previousEndPosition = endPosition
                    endPosition = endPosition + 1
                    returnedEnd = fillPage(startPosition, endPosition, true)
                    if (pn == pageToLog) console.log("returned end: " + returnedEnd)
                    if (returnedEnd < endPosition) {
                        documentEnd = true
                    }
                    if (pn == pageToLog) console.log("scroll necessary: " + scrollNecessary())
                }
                if (! documentEnd) {
                    if (pn == pageToLog) console.log("suggested end position: " + previousEndPosition)
                    var endpos = fillPage(startPosition, previousEndPosition, false)
                    if (pn == pageToLog) console.log("actual end position: " + endpos)
                    return { "endPosition": endpos, "documentEnd": false }
                } else {
                    return { "endPosition": returnedEnd, "documentEnd": true}
                }
            }*/
            function clearPage() {
                document.getElementById("page").innerHTML = ""
            }

            /*function fillPage(startPosition, endPosition, handleWords) {
                var content = document.getElementById("content")
                var range = document.createRange()
                var startLocation = findLocation(content, startPosition, false)
                var endLocation = findLocation(content, endPosition, handleWords)
                range.setStart(startLocation.element, startLocation.position)
                if (endLocation != null && endLocation.element) {
                    range.setEnd(endLocation.element, endLocation.position)
                } else {
                    var contentAll = document.querySelectorAll("#content > *")
                    var lastElement = contentAll[contentAll.length - 1]
                    range.setEndAfter(lastElement)
                }
                var page = document.getElementById("page")
                page.innerHTML = ""
                page.appendChild(range.cloneContents())
                if (endLocation.remaining) {
                    return endPosition - endLocation.remaining
                } else {
                    return endPosition
                }
            }*/

            /*function positionOfSpaceBefore(str, pos) {
                for (var i = pos; i > 0; i--) {
                    if (str.charAt(i) == ' ') return i
                }
                return 0
            }*/

            /*function findSpaceAfter(position) {
                var el = document.getElementById("content")
                var text = betterTextContent(el)
                for (var i = position + 1; i < text.length; i++) {
                    // treat multiple spaces as one ?
                    if (text.charAt(i) == ' ') return i
                }
                return text.length
            }*/

            /*function betterTextContent(el) {
                if (el.nodeType == Node.TEXT_NODE) {
                    return el.nodeValue
                } else if (el.nodeType == Node.ELEMENT_NODE) {
                    var children = el.childNodes
                    var text = ""
                    for (var i = 0; i < children.length; i++) {
                        text = text + " " + betterTextContent(children[i])
                    }
                    return text
                } else return ""
            }*/

            function findSpaceAfter(str, pos) {
                for (var i = pos; i < str.length; i++) {
                    if (str.charAt(i) == ' ') return i
                }
                return str.length
            }

            /*function findLocation(el, position, handleWords) {
                if (el.nodeType == Node.TEXT_NODE) {
                    if (el.nodeValue.length >= position) {
                        if (handleWords) {
                            return { "element": el, "position": findSpaceAfter(el.nodeValue, position) }
                        } else {
                            return { "element": el, "position": position }
                        }
                    } else {
                        return { "remaining": position - el.nodeValue.length}
                    }
                } else if (el.nodeType == Node.ELEMENT_NODE) {
                    var children = el.childNodes
                    var remainingPosition = position
                    for (var i = 0; i < children.length; i++) {
                        var result = findLocation(children[i], remainingPosition, handleWords)
                        if (result.element) {
                            return result
                        } else {
                            remainingPosition = result.remaining
                        }
                    }
                    return { "remaining": remainingPosition}
                }
                return null
            }*/

            function computeStartPositionsOfElements(root) {
                console.log("computing start positions of elements")
                var positionToElement = [] //new Map()
                //var elementToPosition = new Map()
                var recursive = function(element, currentPosition) {
                    if (element.nodeType == Node.TEXT_NODE) {
                        //elementToPosition.set(element, currentPosition)
                        positionToElement.push([currentPosition, element])
                        return currentPosition + element.nodeValue.length
                    } else if (element.nodeType == Node.ELEMENT_NODE) {
                        var children = element.childNodes
                        var newCurrentPosition = currentPosition
                        for (var i = 0; i < children.length; i++) {
                            newCurrentPosition = recursive(children[i], newCurrentPosition)
                        }
                        return newCurrentPosition
                    }
                }
                recursive(root, 0)
                return positionToElement
            }

            function getElementForPosition(positions, position) {
                if (debugLogging) console.log(positions)
                if (debugLogging) console.log("getting element for position " + position)
                for (var i = 1; i < positions.length; i++) {
                    if (positions[i][0] > position) return positions[i-1]
                }
                console.log("no element found for position")
                return positions[positions.length - 1]
            }
            function getPositions() {
                return document.positions
            }
            function setPositions(positions) {
                document.positions = positions
            }
            function getMaxPosition() {
                var last = document.positions[document.positions.length - 1]
                return last[0] + last[1].nodeValue.length
            }

            // find the end position for this start position that constituder a full page
            function findPage(startPosition) {
                var initialJump = 100
                var endPosition = getNextSpaceForPosition(getPositions(), startPosition + initialJump)
                var previousEndPosition = null
                //console.log(endPosition)
                copyTextToPage(getPositions(), startPosition, endPosition)
                while ((! scrollNecessary()) && (endPosition < getMaxPosition())) {
                    previousEndPosition = endPosition
                    endPosition = getNextSpaceForPosition(getPositions(), endPosition + 1)
                    copyTextToPage(getPositions(), startPosition, endPosition)
                    //console.log(endPosition)
                }
                if (scrollNecessary() && previousEndPosition != null) {
                    copyTextToPage(getPositions(), startPosition, previousEndPosition)
                    return previousEndPosition
                } else {
                    return endPosition
                }
            }

            var debugLogging = false

            function findPages() {
                var pages = []
                pages.push(0)
                while (pages[pages.length - 1] < getMaxPosition() && pages.length < 100) {
                    var endPosition = findPage(pages[pages.length - 1])
                    console.log(endPosition)
                    pages.push(endPosition)
                }
                clearPage()
                console.log(pages)
                document.pages = pages
                document.currentPage = 0
                debugLogging = true
                //fillPage(document.pages[0], document.pages[1], false)
                copyTextToPage(getPositions(), document.pages[0], document.pages[1])
            }


            function copyTextToPage(positions, from, to) {
                var range = document.createRange()

                var startEl = getElementForPosition(positions, from)
                if (debugLogging) console.log(startEl)
                var startElement = startEl[1]
                var locationInStartEl = from - startEl[0]
                //console.log(locationInStartEl)
                range.setStart(startElement, locationInStartEl)

                var endEl = getElementForPosition(positions, to)
                //console.log(endEl)
                var locationInEndEl = to - endEl[0]
                range.setEnd(endEl[1], locationInEndEl)

                var page = document.getElementById("page")
                page.innerHTML = ""
                page.appendChild(range.cloneContents())
            }

            function getNextSpaceForPosition(positions, position) {
                var index = null
                for (var i = 1; i < positions.length-1; i++) {
                    if (positions[i][0] > position) {
                        index = i - 1
                        break
                    }
                }
                if (index == null) return getMaxPosition()

                if (debugLogging) console.log("index for element containing space: " + index)
                if (debugLogging) console.log("element text: " + positions[index][1].nodeValue)
                if (debugLogging) console.log("size of text: " + positions[index][1].nodeValue.length)
                if (debugLogging) console.log("looking for space after position: " + (position - positions[index][0]))
                var nextSpaceInElementText = findSpaceAfter(positions[index][1].nodeValue, position - positions[index][0])
                if (debugLogging) console.log("found space at: " + nextSpaceInElementText)


                if (nextSpaceInElementText < positions[index][1].nodeValue.length) {
                    return positions[index][0] + nextSpaceInElementText
                } else {
                    if (index < positions.length-1) {
                        return positions[index+1][0]
                    } else {
                        return getMaxPosition()
                    }
                }
            }

            function scrollNecessary() {
                return (document.body.scrollWidth > document.body.clientWidth) || (document.body.scrollHeight > document.body.clientHeight)
            }
        </script>
    </head>
    <body>
        <div id="content"></div>
        <div id="prev"></div>
        <div id="next"></div>
        <div id="page"></div>
        <script>
            var prev = document.getElementById("prev")
            prev.addEventListener("click", function() {
                previousPage()
            })
            var next = document.getElementById("next")
            next.addEventListener("click", function() {
                nextPage()
            })

            getData(() => {
                var positions = computeStartPositionsOfElements(document.getElementById("content"))
                setPositions(positions)
                console.log("max position: " + getMaxPosition())
                //var endPage = findPage(0)
                //console.log(endPage)
                findPages()
                //findPage(45993)
            })
        </script>
    </body>
</html>