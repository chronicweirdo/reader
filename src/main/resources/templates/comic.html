<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="https://www.thymeleaf.org"
      xmlns:sec="https://www.thymeleaf.org/thymeleaf-extras-springsecurity3">
<head>
    <meta name="viewport"
          content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="comicId" content="1" th:content="${id}">
    <meta name="comicTitle" content="1" th:content="${title}">
    <meta name="pages" content="20" th:content=${pages}>
    <meta name="startPage" content="0" th:content=${startPage}>
    <meta name="defaultFit" content="screen">
    <title th:text="${title}">Comic Title</title>
    <style>
    * {
        margin: 0;
        padding: 0;
        border: 0;
    }
    body {
        text-align: center;
        user-select: none; /* standard syntax */
        -webkit-user-select: none; /* webkit (safari, chrome) browsers */
        -moz-user-select: none; /* mozilla browsers */
        -khtml-user-select: none; /* webkit (konqueror) browsers */
        -ms-user-select: none; /* IE10+ */
    }
    #prev {
        display: block;
        position: fixed;
        top: 0;
        left: 0;
        width: 10vw;
        height: 100vh;
    }
    #next {
        display: block;
        position: fixed;
        top: 0;
        right: 0;
        width: 10vw;
        height: 100vh;
    }
    #canv {
        display: block;
        position: fixed;
        top: 0;
        left: 10vw;
        width: 80vw;
        height: 100vh;
    }
    #tools {
        display: block;
        position: fixed;
        bottom: 5vh;
        width: 30vw;
        left: 34vw;
        background-color: black;
        color: white;
        border: 1px solid gold;
        padding: 1vw;
        text-align: center;
        font-size: 1.3em;
    }
    #tools h1 {
        margin-bottom: 2vh;
        font-size: 1em;
    }
    #tools p {
        margin-top: 2vh;
    }
    #tools input {
        font-size: 1em;
        background-color: gold;
        padding: .1em;
        width: 5vw;
    }
    #tools a {
        color: gold;
        text-decoration: underline;
        margin-left: .5em;
        margin-right: .5em;
        display: inline-block;
    }
    #spinner {
        position: fixed;
        bottom: 0;
        right: 0;
        width: 5vw;
        height: 5vw;
        display: none;
    }
    #spinner svg {
        width: 100%;
        height: 100%
    }
    p {
        text-align: center;
    }
    img {
        position: fixed;
    }

    @media	only screen and (-webkit-min-device-pixel-ratio: 1.3),
    only screen and (-o-min-device-pixel-ratio: 13/10),
    only screen and (min-resolution: 120dpi)
    {
        #spinner {
            width: 15vw;
            height: 15vw;
        }
        #tools {
            width: 90vw;
            left: 4vw;
        }
        #tools input {
            width: 15vw;
        }
    }
    </style>
    <script src="hammer.min.js"></script>
    <script src="gestures.js"></script>
    <script>
    function num(s, def) {
        var patt = /[\-]?[0-9\.]+/
        var match = patt.exec(s)
        if (match != null && match.length > 0) {
            var n = match[0]
            if (n.indexOf('.') > -1) {
                return parseFloat(n)
            } else {
                return parseInt(n)
            }
        }
        return def
    }

    function getViewportWidth() {
        return Math.max(document.documentElement.clientWidth, window.innerWidth || 0)
    }
    function getViewportHeight() {
        return Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
    }
    function pan(x, y) {
        setImageLeft(getImageLeft() + x)
        setImageTop(getImageTop() + y)
        updateImage()
    }
    function zoom(zoom, centerX, centerY) {
        var sideLeft = centerX - getImageLeft()
        var ratioLeft = sideLeft / (getImageWidth() * getZoom())
        var newSideLeft = (getImageWidth() * zoom) * ratioLeft
        setImageLeft(centerX - newSideLeft)

        var sideTop = centerY - getImageTop()
        var ratioTop = sideTop / (getImageHeight() * getZoom())
        var newSideTop = (getImageHeight() * zoom) * ratioTop
        setImageTop(centerY - newSideTop)

        setZoom(zoom)
        updateImage()
    }
    function toggleFullScreen() {
        var doc = window.document;
        var docEl = doc.documentElement;

        var requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
        var cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;

        if(!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
            requestFullScreen.call(docEl);
        }
        else {
            cancelFullScreen.call(doc);
        }
    }
    function makeFullScreen() {
        var doc = window.document;
        var docEl = doc.documentElement;

        var requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;

        requestFullScreen.call(docEl);
    }
    function unmakeFullScreen() {
        var doc = window.document;

        var cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;

        cancelFullScreen.call(doc);
    }

    function isAutoFullScreenEnabled() {
        return false;
    }

    function updateImage() {
        if (onMobile() && isAutoFullScreenEnabled()) {
            if (isPageFitToScreen()) {
                unmakeFullScreen()
            } else {
                makeFullScreen()
            }
        }

        var img = getImage()

        if (getZoom() < getMinimumZoom()) setZoom(getMinimumZoom())

        var newWidth = getOriginalImageWidth() * getZoom()
        var newHeight = getOriginalImageHeight() * getZoom()
        setImageWidth(newWidth)
        setImageHeight(newHeight)

        var minimumLeft = (newWidth < getViewportWidth()) ? (getViewportWidth() / 2) - (newWidth / 2) : Math.min(0, getViewportWidth() - newWidth)
        var maximumLeft = (newWidth < getViewportWidth()) ? (getViewportWidth() / 2) - (newWidth / 2) : Math.max(0, getViewportWidth() - newWidth)
        var minimumTop = (newHeight < getViewportHeight()) ? (getViewportHeight() / 2) - (newHeight / 2) : Math.min(0, getViewportHeight() - newHeight)
        var maximumTop = (newHeight < getViewportHeight()) ? (getViewportHeight() / 2) - (newHeight / 2) : Math.max(0, getViewportHeight() - newHeight)

        if (getImageLeft() < minimumLeft) setImageLeft(minimumLeft)
        if (getImageLeft() > maximumLeft) setImageLeft(maximumLeft)
        if (getImageTop() < minimumTop) setImageTop(minimumTop)
        if (getImageTop() > maximumTop) setImageTop(maximumTop)
    }
    function getImage() {
        return document.getElementsByTagName("img")[0]
    }
    function getRevertScrollZoom() {
        return true
    }
    function getScrollSpeed() {
        return .5 * .1
    }

    function getPanSpeed() {
        return 3
    }

    function zoomJump(event) {
        if (isPageFitToScreen()) {
            zoom(getZoom() * 2.5, event.clientX, event.clientY)
        } else {
            fitPageToScreen()
        }
    }

    function fitPageToScreenWidth() {
        setZoom(getViewportWidth() / getOriginalImageWidth())
        updateImage()
    }

    function fitPageToScreenHeight() {
        setZoom(getViewportHeight() / getOriginalImageHeight())
        updateImage()
    }

    function isPageFitToScreen() {
        return getZoomForFitToScreen() == getZoom()
    }

    function getZoomForFitToScreen() {
        return Math.min(getViewportHeight() / getOriginalImageHeight(), getViewportWidth() / getOriginalImageWidth())
    }

    function fitPageToScreen() {
        setZoom(getZoomForFitToScreen())
        updateImage()
    }

    function setPage(page) {
        if (page < 1) page = 1
        if (page > document.comicMaximumPages) page = document.comicMaximumPages
        document.getElementById("pagenum").value = page
    }
    function getPage() {
        return num(document.getElementById("pagenum").value)
    }
    function setImageWidth(width) {
        getImage().width = width
    }
    function getImageWidth() {
        return getImage().width
    }
    function setImageHeight(height) {
        getImage().height = height
    }
    function getImageHeight() {
        return getImage().height
    }
    function getOriginalImageWidth() {
        return getImage().naturalWidth
    }
    function getOriginalImageHeight() {
        return getImage().naturalHeight
    }
    function getHorizontalJumpPercentage() {
        if (getViewportHeight() > getViewportWidth()) return .9
        else return .5
    }
    function getVerticalJumpPercentage() {
        if (getViewportHeight() > getViewportWidth()) return .5
        else return .9
    }
    function setImageLeft(left) {
        getImage().style.left = left + "px"
    }
    function getImageLeft() {
        return num(getImage().style.left, 0)
    }
    function setImageTop(top) {
        getImage().style.top = top + "px"
    }
    function getImageTop() {
        return num(getImage().style.top, 0)
    }
    function setZoom(zoom) {
        document.imageSettings.zoom = zoom
    }
    function getZoom() {
        return document.imageSettings.zoom
    }
    // minimum zoom is determined by image and viewport dimensions
    function updateMinimumZoom() {
        document.imageSettings.minimumZoom = Math.min(getViewportHeight() / getOriginalImageHeight(), getViewportWidth() / getOriginalImageWidth())
    }
    function getMinimumZoom() {
        return document.imageSettings.minimumZoom
    }

    function evictOldest() {
        if (document.comicPageCache) {
            var oldest = null
            var oldestPage = null
            for (let [key, value] of Object.entries(document.comicPageCache)) {
                if (oldest == null) {
                    oldest = value.timestamp
                    oldestPage = key
                } else if (value.timestamp < oldest) {
                    oldest = value.timestamp
                    oldestPage = key
                }
            }
            delete document.comicPageCache[oldestPage]
        }
    }
    function getMaximumCacheSize() {
        return 10
    }
    function getCacheSize() {
        return Object.keys(document.comicPageCache).length
    }
    function addToCache(page, data) {
        if (! document.comicPageCache) document.comicPageCache = {}
        document.comicPageCache[page] = {
            "timestamp": + new Date(),
            "data": data
        }
        // evict some old data if cache is too large
        while (getCacheSize() > getMaximumCacheSize()) {
            evictOldest()
        }
    }
    function getFromCache(page) {
        if (document.comicPageCache && document.comicPageCache[page] && document.comicPageCache[page] != null) {
            return document.comicPageCache[page].data
        } else {
            return null
        }
    }
    function cacheContains(page) {
        if (document.comicPageCache && document.comicPageCache[page] && document.comicPageCache[page] != null) {
            return true
        } else {
            return false
        }
    }

    function markComicProgress(page) {
        var xhttp = new XMLHttpRequest()
        xhttp.open("PUT", "markProgress?id=" + getComicId() + "&position=" + (page-1), true)
        xhttp.send()
    }

    function downloadImageData(page, callback) {
        var xhttp = new XMLHttpRequest()
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200 && this.responseText.length > 0) {
                addToCache(page, this.responseText)
                if (callback != null) {
                    callback()
                }
            }
        }
        xhttp.open("GET", "imageData?id=" + getComicId() + "&page=" + (page-1), true)
        xhttp.send()
    }

    function prefetch(page, callback) {
        if (! cacheContains(page)) {
            downloadImageData(page, callback)
        } else {
            if (callback != null) {
                callback()
            }
        }
    }

    function displayPage(page, callback) {
        var timestamp = + new Date()
        showSpinner()
        document.pageDisplayTimestamp = timestamp
        var displayPageInternalCallback = function(data) {
            if (document.pageDisplayTimestamp == timestamp) {
                hideSpinner()
                var img = getImage()
                img.onload = function() {
                    setPage(page)
                    markComicProgress(page)
                    setPageTitle(page + "/" + document.comicMaximumPages + " - " + document.comicTitle)
                    setImageWidth(getOriginalImageWidth())
                    setImageHeight(getOriginalImageHeight())
                    setImageLeft(0)
                    setImageTop(0)
                    updateMinimumZoom()
                    if (callback != null) {
                        callback()
                    }
                    prefetch(page+1, function() {
                        prefetch(page+2, function() {
                            prefetch(page+3, function() {
                                prefetch(page-1, function() {
                                    prefetch(page-2, null)
                                })
                            })
                        })
                    })
                }
                img.src = data
            }
        }
        var imageData = getFromCache(page)
        if (imageData != null) {
            displayPageInternalCallback(imageData)
        } else {
            downloadImageData(page, function() {
                displayPageInternalCallback(getFromCache(page))
            })
        }
    }
    function setPageTitle(title) {
        document.title = title
    }

    function approx(val1, val2, threshold = 1) {
        return Math.abs(val1 - val2) < threshold
    }

    function getRowThreshold() {
        return getImageWidth() * .1
    }

    function getColumnThreshold() {
        return getImageHeight() * .1
    }

    function isEndOfRow() {
        return (getImage().width <= getViewportWidth()) || approx(getImageLeft() + getImageWidth(), getViewportWidth(), getRowThreshold())
    }
    function isBeginningOfRow() {
        return (getImage().width <= getViewportWidth()) || approx(getImageLeft(), 0, getRowThreshold())
    }

    function isEndOfColumn() {
        return (getImage().height <= getViewportHeight()) || approx(getImageTop() + getImageHeight(), getViewportHeight(), getColumnThreshold())
    }
    function isBeginningOfColumn() {
        return (getImage().height <= getViewportHeight()) || approx(getImageTop(), 0, getColumnThreshold())
    }

    function getNextPosition(imageDimension, viewportDimension, imageValue, viewportJumpPercentage, threshold) {
        if (approx(imageValue, viewportDimension - imageDimension, threshold)) return 0
        var proposedNextPosition = (imageValue - viewportDimension *  viewportJumpPercentage) | 0
        if (proposedNextPosition < viewportDimension - imageDimension) return viewportDimension - imageDimension
        return proposedNextPosition
    }
    function getPreviousPosition(imageDimension, viewportDimension, imageValue, viewportJumpPercentage, threshold) {
        if (approx(imageValue, 0, threshold)) return viewportDimension - imageDimension
        var proposedPreviousPosition = (imageValue + viewportDimension * viewportJumpPercentage) | 0
        if (proposedPreviousPosition > 0) return 0
        return proposedPreviousPosition
    }

    function getComicId() {
        return document.comicId
    }

    function goToNextPage() {
        if (getPage() < document.comicMaximumPages) {
            displayPage(getPage() + 1, function() {
                updateImage()
            })
        }
    }

    function goToPreviousPage() {
        if (getPage() > 1) {
            displayPage(getPage() - 1, function() {
                updateImage()
            })
        }
    }

    function goToNextView() {
        if (isEndOfRow()) {
            if (isEndOfColumn()) {
                goToNextPage()
            } else {
                setImageLeft(getNextPosition(getImage().width, getViewportWidth(), getImageLeft(), getHorizontalJumpPercentage(), getRowThreshold()))
                setImageTop(getNextPosition(getImage().height, getViewportHeight(), getImageTop(), getVerticalJumpPercentage(), getColumnThreshold()))
                updateImage()
            }
        } else {
            setImageLeft(getNextPosition(getImage().width, getViewportWidth(), getImageLeft(), getHorizontalJumpPercentage(), getRowThreshold()))
            updateImage()
        }
    }

    function showSpinner() {
        var spinner = document.getElementById("spinner")
        spinner.style.display = "block"
    }

    function hideSpinner() {
        var spinner = document.getElementById("spinner")
        spinner.style.display = "none"
    }

    function showTools() {
        var tools = document.getElementById("tools")
        tools.style.visibility = "visible"
    }

    function hideTools() {
        var tools = document.getElementById("tools")
        tools.style.visibility = "hidden"
    }

    function toggleTools(x, y) {
        var tools = document.getElementById("tools")
        if (tools.style.visibility == "hidden") {
            tools.style.visibility = "visible"
        } else {
            tools.style.visibility = "hidden"
        }
    }

    function goToPreviousView() {
        if (isBeginningOfRow()) {
            if (isBeginningOfColumn()) {
                goToPreviousPage()
            } else {
                setImageLeft(getPreviousPosition(getImage().width, getViewportWidth(), getImageLeft(), getHorizontalJumpPercentage(), getRowThreshold()))
                setImageTop(getPreviousPosition(getImage().height, getViewportHeight(), getImageTop(), getVerticalJumpPercentage(), getColumnThreshold()))
                updateImage()
            }
        } else {
            setImageLeft(getPreviousPosition(getImage().width, getViewportWidth(), getImageLeft(), getHorizontalJumpPercentage(), getRowThreshold()))
            updateImage()
        }

    }

    function getMeta(metaName) {
        const metas = document.getElementsByTagName('meta');

        for (let i = 0; i < metas.length; i++) {
            if (metas[i].getAttribute('name') === metaName) {
            return metas[i].getAttribute('content');
            }
        }

        return '';
    }

    function onMobile() {
        if (navigator.userAgent.match(/Android/i)
            || navigator.userAgent.match(/webOS/i)
            || navigator.userAgent.match(/iPhone/i)
            || navigator.userAgent.match(/iPad/i)
            || navigator.userAgent.match(/iPod/i)
            || navigator.userAgent.match(/BlackBerry/i)
            || navigator.userAgent.match(/Windows Phone/i)) {
                return true
            } else {
                return false
            }
    }

    function handleResize() {
        updateMinimumZoom()
        updateImage()
    }

    function jumpToPage() {
        var page = getPage()
        displayPage(page, function() {
            updateImage()
        })
    }

    function addPagenumTriggerListener() {
        var pagenum = document.getElementById("pagenum")
        pagenum.addEventListener('keyup', function (e) {
            if (document.pageChangeTimeout && document.pageChangeTimeout != null) {
                window.clearTimeout(document.pageChangeTimeout)
                document.pageChangeTimeout = null
            }
            if (e.keyCode === 13) {
                // if enter, search
                jumpToPage()
            } else {
                // if other key, wait to see if finished typing
                document.pageChangeTimeout = window.setTimeout(jumpToPage, 1000)
            }
        })
        pagenum.addEventListener('mouseup', function (e) {
            jumpToPage()
        })
    }

    function removeProgress() {
        var xhttp = new XMLHttpRequest()
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4) {
                if (this.status == 200) {
                    window.location = "/"
                }
            }
        }
        xhttp.open("DELETE", "removeProgress?id=" + document.comicId, true)
        xhttp.send()
    }

    function goBack() {
        window.history.back();
    }

    function enableKeyboardGestures() {
        document.onkeydown = function(e) {
            if (e.keyCode == '38' || e.keyCode == '87') {
                // up arrow or w
                pan(0, getViewportHeight() / 2)
            }
            else if (e.keyCode == '40' || e.keyCode == '83') {
                // down arrow or s
                pan(0, - (getViewportHeight() / 2))
            }
            else if (e.keyCode == '37' || e.keyCode == '65') {
                // left arrow or a
                goToPreviousView()
            }
            else if (e.keyCode == '39' || e.keyCode == '68') {
                // right arrow or d
                goToNextView()
            }
        }
    }

</script>
</head>
<body onresize="handleResize()">
<img src="" />
<div id="prev"></div>
<div id="next"></div>
<div id="canv"></div>
<div id="tools">
    <h1 th:text="${title}">Comic Title</h1>
    <p><a th:href="@{/(search=${collection})}" th:text="${collection}">collection</a></p>
    <p>Page <input id="pagenum" type="number"  min="1" th:max="${pages}"/> of <span th:text="${pages}">20</span></p>
    <p>
        <a onclick="toggleFullScreen()">fullscreen</a>
        <a onclick="goBack()">back</a>
        <a onclick="removeProgress()">remove progress</a>
    </p>
</div>
<div id="spinner">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="margin:auto;display:block;" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid">
        <rect x="20" y="20" width="60" height="60" stroke="#000000" stroke-width="10" fill="none"></rect>
        <rect x="20" y="20" width="60" height="60" stroke="#ffd700" stroke-width="10" stroke-lincap="undefined" fill="none">
            <animate attributeName="stroke-dasharray" repeatCount="indefinite" dur="1s" keyTimes="0;0.5;1" values="24 216;120 120;24 216"></animate>
            <animate attributeName="stroke-dashoffset" repeatCount="indefinite" dur="1s" keyTimes="0;0.5;1" values="0;-120;-240"></animate>
        </rect>
    </svg>
</div>
<script>
        function mouseGestureDrag(mouseButtonPressed, deltaX, deltaY) {
            if (mouseButtonPressed) {
                pan(deltaX * getPanSpeed(), deltaY * getPanSpeed())
            }
        }
        function mouseGestureScroll(scrollCenterX, scrollCenterY, scrollValue) {
            var zoomDelta = 1 + scrollValue * getScrollSpeed() * (getRevertScrollZoom() ? -1 : 1)
            var newZoom = getZoom() * zoomDelta
            zoom(newZoom, scrollCenterX, scrollCenterY)
        }
        function touchGesturePinchStart(pinchCenterX, pinchCenterY) {
            document.originalZoom = getZoom()
        }
        function touchGesturePinchOngoing(currentZoom, pinchCenterX, pinchCenterY) {
            zoom(document.originalZoom * currentZoom, pinchCenterX, pinchCenterY)
        }
        function touchGesturePan(deltaX, deltaY) {
            pan(deltaX * getPanSpeed(), deltaY * getPanSpeed())
        }
        window.onload = function() {
            enableKeyboardGestures()

            // supported actions:
            // clickAction(mouseX, mouseY)
            // doubleClickAction(mouseX, mouseY)
            // mouseMoveAction(mouseButtonPressed, deltaX, deltaY)
            // scrollAction(scrollCenterX, scrollCenterY, scrollValue)
            // pinchStartAction(pinchCenterX, pinchCenterY)
            // pinchAction(currentZoom, pinchCenterX, pinchCenterY)
            // panAction(deltaX, deltaY)
            var originalZoom = null

            enableGesturesOnElement(
                document.getElementById("canv"),
                toggleTools,
                zoomJump,
                mouseGestureDrag,
                mouseGestureScroll,
                touchGesturePinchStart,
                touchGesturePinchOngoing,
                touchGesturePan
            )

            enableGesturesOnElement(
                document.getElementById("prev"),
                (x, y) => goToPreviousView(),
                zoomJump,
                mouseGestureDrag,
                mouseGestureScroll,
                touchGesturePinchStart,
                touchGesturePinchOngoing,
                touchGesturePan
            )
            enableGesturesOnElement(
                document.getElementById("next"),
                (x, y) => goToNextView(),
                zoomJump,
                mouseGestureDrag,
                mouseGestureScroll,
                touchGesturePinchStart,
                touchGesturePinchOngoing,
                touchGesturePan
            )

            addPagenumTriggerListener()

            document.comicId = getMeta("comicId")
            document.comicTitle = getMeta("comicTitle")
            document.comicMaximumPages = num(getMeta("pages"))
            document.imageSettings = {}
            setZoom(1.0)
            var startPage = num(getMeta("startPage")) + 1

            displayPage(startPage, function() {
                var fit = getMeta("defaultFit")
                if (fit == "width") {
                    fitPageToScreenWidth()
                } else if (fit = "screen") {
                    fitPageToScreen()
                }
            })
        }
    </script>
</body>
</html>