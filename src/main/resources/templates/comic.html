<!DOCTYPE html>
<html>
<head>
    <meta name="viewport"
          content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="comicId" content="1" th:content="${id}">
    <meta name="pages" content="20" th:content=${pages}>
    <meta name="startPage" content="0" th:content=${startPage}>
    <meta name="defaultFit" content="screen">
    <style>
    * {
        margin: 0;
        padding: 0;
        border: 0;
    }
    body {
        user-select: none; /* standard syntax */
        -webkit-user-select: none; /* webkit (safari, chrome) browsers */
        -moz-user-select: none; /* mozilla browsers */
        -khtml-user-select: none; /* webkit (konqueror) browsers */
        -ms-user-select: none; /* IE10+ */
    }
    #prev {
        display: block;
        position: fixed;
        top: 0;
        left: 0;
        width: 10vw;
        height: 100vh;
        /*background-color: green;*/
        opacity: .5;
    }
    #next {
        display: block;
        position: fixed;
        top: 0;
        right: 0;
        width: 10vw;
        height: 100vh;
        /*background-color: blue;*/
        opacity: .5;
    }
    #canv {
        display: block;
        position: fixed;
        top: 0;
        left: 10vw;
        width: 80vw;
        height: 100vh;
        /*background-color: yellow;*/
        opacity: .5;
    }
    p {
        text-align: center;
    }
    img {
        position: fixed;
    }
</style>
    <script src="hammer.min.js"></script>
    <script>
    function num(s, def) {
        var patt = /[\-]?[0-9\.]+/
        var match = patt.exec(s)
        if (match != null && match.length > 0) {
            var n = match[0]
            if (n.indexOf('.') > -1) {
                return parseFloat(n)
            } else {
                return parseInt(n)
            }
        }
        return def
    }

    function getViewportWidth() {
        return Math.max(document.documentElement.clientWidth, window.innerWidth || 0)
    }
    function getViewportHeight() {
        return Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
    }
    function pan(x, y) {
        setImageLeft(getImageLeft() + x)
        setImageTop(getImageTop() + y)
        updateImage()
    }
    function zoom(zoom, centerX, centerY) {
        var sideLeft = centerX - getImageLeft()
        var ratioLeft = sideLeft / (getImageWidth() * getZoom())
        var newSideLeft = (getImageWidth() * zoom) * ratioLeft
        setImageLeft(centerX - newSideLeft)

        var sideTop = centerY - getImageTop()
        var ratioTop = sideTop / (getImageHeight() * getZoom())
        var newSideTop = (getImageHeight() * zoom) * ratioTop
        setImageTop(centerY - newSideTop)

        setZoom(zoom)
        updateImage()
    }
    function updateImage() {
        var img = getImage()

        if (getZoom() < getMinimumZoom()) setZoom(getMinimumZoom())

        var newWidth = getOriginalImageWidth() * getZoom()
        var newHeight = getOriginalImageHeight() * getZoom()
        setImageWidth(newWidth)
        setImageHeight(newHeight)

        var minimumLeft = (newWidth < getViewportWidth()) ? (getViewportWidth() / 2) - (newWidth / 2) : Math.min(0, getViewportWidth() - newWidth)
        var maximumLeft = (newWidth < getViewportWidth()) ? (getViewportWidth() / 2) - (newWidth / 2) : Math.max(0, getViewportWidth() - newWidth)
        var minimumTop = (newHeight < getViewportHeight()) ? (getViewportHeight() / 2) - (newHeight / 2) : Math.min(0, getViewportHeight() - newHeight)
        var maximumTop = (newHeight < getViewportHeight()) ? (getViewportHeight() / 2) - (newHeight / 2) : Math.max(0, getViewportHeight() - newHeight)

        if (getImageLeft() < minimumLeft) setImageLeft(minimumLeft)
        if (getImageLeft() > maximumLeft) setImageLeft(maximumLeft)
        if (getImageTop() < minimumTop) setImageTop(minimumTop)
        if (getImageTop() > maximumTop) setImageTop(maximumTop)
    }
    function getImage() {
        return document.getElementsByTagName("img")[0]
    }
    var revertScrollZoom = true
    var scrollSpeed = .5 * .1
    function mouseWheelScroll(i) {
        var zoomCenterX = i.clientX
        var zoomCenterY = i.clientY
        var zoomDelta = 1 + i.deltaY * scrollSpeed * (revertScrollZoom ? -1 : 1)
        var newZoom = getZoom() * zoomDelta
        zoom(newZoom, zoomCenterX, zoomCenterY)
    }
    var drag = false;
    function mouseDown(e) {
        e.preventDefault()
        drag = true;
    }
    function mouseUp(e) {
        drag = false;
    }
    var panSpeed = 2
    function mouseMove(e) {
        if (drag) {
            pan(e.movementX * panSpeed, e.movementY * panSpeed)
        }
    }

    function fitPageToScreenWidth() {
        setZoom(getViewportWidth() / getImageWidth())
        updateImage()
    }

    function fitPageToScreenHeight() {
        setZoom(getViewportHeight() / getImageHeight())
        updateImage()
    }

    function fitPageToScreen() {
        setZoom(Math.min(getViewportHeight() / getOriginalImageHeight(), getViewportWidth() / getOriginalImageWidth()))
        updateImage()
    }

    function disableEventHandlers(el) {
        var events = ['onclick', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover',
                      'onmouseup', 'ondblclick', 'onfocus', 'onblur'];

        events.forEach(function (event) {
          el[event] = function () {
            return false;
          };
        });
      };

    function enableTouchGestures(element) {
        disableEventHandlers(element)
        var hammertime = new Hammer(element, {
            domEvents: true
            });
        hammertime.get('pan').set({ direction: Hammer.DIRECTION_ALL, threshold: 0 });
        hammertime.get('pinch').set({ enable: true });

        var touchscreenPanAttenuator = 1
        var panPreviousDeltaX = 0
        var panPreviousDeltaY = 0

        hammertime.on('pan', function(ev) {
            var currentDeltaX = ev.deltaX - panPreviousDeltaX
            var currentDeltaY = ev.deltaY - panPreviousDeltaY
            pan(currentDeltaX * touchscreenPanAttenuator, currentDeltaY * touchscreenPanAttenuator)
            panPreviousDeltaX = ev.deltaX
            panPreviousDeltaY = ev.deltaY
        });
        hammertime.on('panend', function(ev) {
            panPreviousDeltaX = 0
            panPreviousDeltaY = 0
        });

        var originalZoom = null
        var pinchCenterX = null
        var pinchCenterY = null
        hammertime.on('pinchstart', function(ev) {
            ev.preventDefault();
            originalZoom = getZoom()
            pinchCenterX = ev.center.x
            pinchCenterY = ev.center.y
        })
        hammertime.on('pinch', function(ev) {
            ev.preventDefault()
            zoom(originalZoom * ev.scale, pinchCenterX, pinchCenterY)
        });
    }

    function setPage(page) {
        document.imageSettings.page = page
    }
    function getPage() {
        return document.imageSettings.page
    }
    function setImageWidth(width) {
        getImage().width = width
    }
    function getImageWidth() {
        return getImage().width
    }
    function setImageHeight(height) {
        getImage().height = height
    }
    function getImageHeight() {
        return getImage().height
    }
    function getOriginalImageWidth() {
        return getImage().naturalWidth
    }
    function getOriginalImageHeight() {
        return getImage().naturalHeight
    }
    function setImageLeft(left) {
        getImage().style.left = left + "px"
    }
    function getImageLeft() {
        return num(getImage().style.left, 0)
    }
    function setImageTop(top) {
        getImage().style.top = top + "px"
    }
    function getImageTop() {
        return num(getImage().style.top, 0)
    }
    function setZoom(zoom) {
        document.imageSettings.zoom = zoom
    }
    function getZoom() {
        return document.imageSettings.zoom
    }
    // minimum zoom is determined by image and viewport dimensions
    function updateMinimumZoom() {
        document.imageSettings.minimumZoom = Math.min(getViewportHeight() / getOriginalImageHeight(), getViewportWidth() / getOriginalImageWidth())
    }
    function getMinimumZoom() {
        return document.imageSettings.minimumZoom
    }

    function loadImageData(id, page, callback) {
        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200 && this.responseText.length > 0) {
                var img = getImage()
                img.onload = function() {
                    setPage(page)
                    setImageWidth(getOriginalImageWidth())
                    setImageHeight(getOriginalImageHeight())
                    setImageLeft(0)
                    setImageTop(0)
                    updateMinimumZoom()
                    callback()
                }
                img.src = this.responseText
            }
        };
        xhttp.open("GET", "imageData?id=" + id + "&page=" + page, true);
        xhttp.send();
    }

    function approx(val1, val2) {
        return Math.abs(val1 - val2) < 1
    }

    function isEndOfRow() {
        return (getImage().width <= getViewportWidth()) || approx(getImageLeft() + getImageWidth(), getViewportWidth())
    }
    function isBeginningOfRow() {
        return (getImage().width <= getViewportWidth()) || approx(getImageLeft(), 0)
    }

    function isEndOfColumn() {
        return (getImage().height <= getViewportHeight()) || approx(getImageTop() + getImageHeight(), getViewportHeight())
    }
    function isBeginningOfColumn() {
        return (getImage().height <= getViewportHeight()) || approx(getImageTop(), 0)
    }

    function computePositions(imageDimension, viewportDimension) {
        if (imageDimension > viewportDimension) {
            var numberOfPositions = Math.ceil(imageDimension / viewportDimension)
            var iter = (imageDimension - viewportDimension) / (numberOfPositions-1)
            var pos = []
            for (var i = 0; i < numberOfPositions; i++) {
                pos.push(- i * iter)
            }
            return pos
        } else {
            return [0]
        }
    }

    function getNextPosition(imageDimension, viewportDimension, imageValue) {
        var positions = computePositions(imageDimension, viewportDimension)
        var i = 0
        while (i < positions.length && positions[i] >= imageValue) i++
        if (i == positions.length) i = 0
        return positions[i]
    }
    function getPreviousPosition(imageDimension, viewportDimension, imageValue) {
        var positions = computePositions(imageDimension, viewportDimension)
        var i = 0
        while (i < positions.length && positions[i] > imageValue) i++
        if (i == 0) i = positions.length
        return positions[i - 1]
    }

    function goToNextPage() {
        if (getPage() < document.comicMaximumPages - 1) {
            loadImageData(document.comicId, getPage() + 1, function() {
                updateImage()
            })
        }
    }

    function goToPreviousPage() {
        if (getPage() > 0) {
            loadImageData(document.comicId, getPage() - 1, function() {
                updateImage()
            })
        }
    }

    function goToNextView() {
        if (isEndOfRow()) {
            if (isEndOfColumn()) {
                goToNextPage()
            } else {
                setImageLeft(getNextPosition(getImage().width, getViewportWidth(), getImageLeft()))
                setImageTop(getNextPosition(getImage().height, getViewportHeight(), getImageTop()))
                updateImage()
            }
        } else {
            setImageLeft(getNextPosition(getImage().width, getViewportWidth(), getImageLeft()))
            updateImage()
        }


    }

    function goToPreviousView() {
        if (isBeginningOfRow()) {
            if (isBeginningOfColumn()) {
                goToPreviousPage()
            } else {
                setImageLeft(getPreviousPosition(getImage().width, getViewportWidth(), getImageLeft()))
                setImageTop(getPreviousPosition(getImage().height, getViewportHeight(), getImageTop()))
                updateImage()
            }
        } else {
            setImageLeft(getPreviousPosition(getImage().width, getViewportWidth(), getImageLeft()))
            updateImage()
        }

    }

    function getMeta(metaName) {
        const metas = document.getElementsByTagName('meta');

        for (let i = 0; i < metas.length; i++) {
            if (metas[i].getAttribute('name') === metaName) {
            return metas[i].getAttribute('content');
            }
        }

        return '';
    }

    function onMobile() {
        if (navigator.userAgent.match(/Android/i)
            || navigator.userAgent.match(/webOS/i)
            || navigator.userAgent.match(/iPhone/i)
            || navigator.userAgent.match(/iPad/i)
            || navigator.userAgent.match(/iPod/i)
            || navigator.userAgent.match(/BlackBerry/i)
            || navigator.userAgent.match(/Windows Phone/i)) {
                return true
            } else {
                return false
            }
    }

    function handleResize() {
        updateMinimumZoom()
        updateImage()
    }

</script>
</head>
<body onresize="handleResize()">
<img src="" />
<div id="prev"></div>
<div id="next"></div>
<div id="canv"></div>
<script>
        window.onload = function() {
            document.onkeydown = function(e) {
                if (e.keyCode == '38') {
                    // up arrow
                }
                else if (e.keyCode == '40') {
                    // down arrow
                }
                else if (e.keyCode == '37') {
                    // left arrow
                    goToPreviousView()
                }
                else if (e.keyCode == '39') {
                    // right arrow
                    goToNextView()
                }
            }

            var canv = document.getElementById("canv")
            enableTouchGestures(canv)
            canv.addEventListener("wheel", mouseWheelScroll)
            canv.addEventListener("mousedown", mouseDown)
            canv.addEventListener("mouseup", mouseUp)
            canv.addEventListener("mouseout", mouseUp)
            canv.addEventListener("mousemove", mouseMove)
            canv.addEventListener("dblclick", function(event) {
                event.preventDefault()
                fitPageToScreen()
            })
            if (! onMobile()) {
                canv.addEventListener("contextmenu", function(ev) {
                    ev.preventDefault()
                    history.back()
                })
            }

            var prevDiv = document.getElementById("prev")
            prevDiv.addEventListener("click", goToPreviousView)
            // click functionality interferes with next div functionality
            /*prevDiv.addEventListener("dblclick", function(event) {
                event.preventDefault()
                goToPreviousPage()
            })*/

            var nextDiv = document.getElementById("next")
            nextDiv.addEventListener("click", goToNextView)
            // click functionality interferes with next div functionality
            /*nextDiv.addEventListener("dblclick", function(event) {
                event.preventDefault()
                goToNextPage()
            })*/

            document.comicId = getMeta("comicId")
            document.comicMaximumPages = num(getMeta("pages"))
            document.imageSettings = {}
            setZoom(1.0)
            var startPage = num(getMeta("startPage"))

            loadImageData(document.comicId, startPage, function() {
                var fit = getMeta("defaultFit")
                if (fit == "width") {
                    fitPageToScreenWidth()
                } else if (fit = "screen") {
                    fitPageToScreen()
                }
            })
        }
    </script>
</body>
</html>