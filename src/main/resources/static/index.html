<html>
<head>
    <meta name="viewport"
        content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">
<style>
    * {
        margin: 0;
        padding: 0;
        border: 0;
    }
    #prev {
        display: block;
        position: fixed;
        top: 10vh;
        left: 0;
        width: 10vw;
        height: 90vh;
        background-color: green;
        opacity: .5;
    }
    #next {
        display: block;
        position: fixed;
        top: 10vh;
        right: 0;
        width: 10vw;
        height: 90vh;
        background-color: blue;
        opacity: .5;
    }
    #top {
        display: block;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 10vh;
        background-color: red;
        opacity: .5;
    }
    #canv {
        display: block;
        position: fixed;
        top: 10vh;
        left: 10vw;
        width: 80vw;
        height: 90vh;
        background-color: yellow;
        opacity: .5;
    }
    p {
        text-align: center;
    }
    img {
        position: fixed;
    }
</style>
<script src="hammer.min.js"></script> 
<script>
    function num(s, def) {
        var patt = /[\-]?[0-9\.]+/
        var match = patt.exec(s)
        if (match != null && match.length > 0) {
            var n = match[0]
            if (n.indexOf('.') > -1) {
                return parseFloat(n)
            } else {
                return parseInt(n)
            }
        }
        return def
    }

    function viewportWidth() {
        return Math.max(document.documentElement.clientWidth, window.innerWidth || 0)
    }
    function viewportHeight() {
        return Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
    }
    function fixPosition() {
        var img = getImage()

        if (document.imageSettings.zoom < document.imageSettings.minimumZoom) document.imageSettings.zoom = document.imageSettings.minimumZoom

        var newWidth = document.imageSettings.width * document.imageSettings.zoom
        var newHeight = document.imageSettings.height * document.imageSettings.zoom

        var minimumLeft = (newWidth < viewportWidth()) ? (viewportWidth() / 2) - (newWidth / 2) : Math.min(0, viewportWidth() - newWidth)
        var maximumLeft = (newWidth < viewportWidth()) ? (viewportWidth() / 2) - (newWidth / 2) : Math.max(0, viewportWidth() - newWidth)
        var minimumTop = (newHeight < viewportHeight()) ? (viewportHeight() / 2) - (newHeight / 2) : Math.min(0, viewportHeight() - newHeight)
        var maximumTop = (newHeight < viewportHeight()) ? (viewportHeight() / 2) - (newHeight / 2) : Math.max(0, viewportHeight() - newHeight)

        if (document.imageSettings.left < minimumLeft) document.imageSettings.left = minimumLeft
        if (document.imageSettings.left > maximumLeft) document.imageSettings.left = maximumLeft
        if (document.imageSettings.top < minimumTop) document.imageSettings.top = minimumTop
        if (document.imageSettings.top > maximumTop) document.imageSettings.top = maximumTop
    }
    function pan(x, y) {
        document.imageSettings.left = document.imageSettings.left + x
        document.imageSettings.top = document.imageSettings.top + y
        fixPosition()
        updateImage()
    }
    function zoom(d) {
        /*var img = getImage()

        var centerOfScreen = viewportHeight() / 2
        var topOfPage = num(img.style.top, 0)
        var topDistance = centerOfScreen - topOfPage

        var newWidth = img.width * d
        var newHeight = img.height * d
        img.width = newWidth
        img.height = newHeight

        var newTopDistance = topDistance * d
        var topPan = topDistance - newTopDistance
        pan(0, newTop)*/
        document.imageSettings.zoom = document.imageSettings.zoom * d
        fixPosition()
        updateImage()
    }
    function updateImage() {
        var img = getImage()
        var settings = document.imageSettings
        //console.log(settings)

        var newWidth = settings.width * settings.zoom
        var newHeight = settings.height * settings.zoom
        img.width = newWidth
        img.height = newHeight

        img.style.left = settings.left
        img.style.top = settings.top
    }
    function getImage() {
        return document.getElementsByTagName("img")[0]
    }
    var revertScrollZoom = true
    var scrollSpeed = .5 * .1
    function mouseWheelScroll(i) {
        //console.log(i.deltaY)
        zoom(1 + i.deltaY * scrollSpeed * (revertScrollZoom ? -1 : 1))
    }
    var drag = false;
    function mouseDown(e) {
        e.preventDefault()
        drag = true;
    }
    function mouseUp(e) {
        drag = false;
    }
    var panSpeed = 4
    function mouseMove(e) {
        if (drag) {
            //console.log(e.movementX)
            //console.log(e.deltaX)
            pan(e.movementX * panSpeed, e.movementY * panSpeed)
        }
    }

    function fitPageToScreenWidth() {
        document.imageSettings.zoom = viewportWidth() / document.imageSettings.width
        fixPosition()
        updateImage()
    }

    function fitPageToScreenHeight() {
        document.imageSettings.zoom = viewportHeight() / document.imageSettings.height
        fixPosition()
        updateImage()
    }

    function fitPageToScreen() {
        document.imageSettings.zoom = Math.min(viewportHeight() / document.imageSettings.height, viewportWidth() / document.imageSettings.width)
        fixPosition()
        updateImage()
    }

    var disableEventHandlers = function (el) {
        //console.log("disabling event handlers for " + el)
        var events = ['onclick', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover',
                      'onmouseup', 'ondblclick', 'onfocus', 'onblur'];

        events.forEach(function (event) {
          el[event] = function () {
            return false;
          };
        });
      };
    
    function enableTouchGestures(element) {
        disableEventHandlers(element)
        var hammertime = new Hammer(element, {
            domEvents: true
            });
        hammertime.get('pan').set({ direction: Hammer.DIRECTION_ALL, threshold: 0 });
        hammertime.get('pinch').set({ enable: true });

        var touchscreenPanAttenuator = 1
        var panPreviousDeltaX = 0
        var panPreviousDeltaY = 0
        
        hammertime.on('pan', function(ev) {
            //console.log(ev);
            //pan(ev.overallVelocityX * touchscreenPanAttenuator, ev.overallVelocityY * touchscreenPanAttenuator)
            var currentDeltaX = ev.deltaX - panPreviousDeltaX
            var currentDeltaY = ev.deltaY - panPreviousDeltaY
            pan(currentDeltaX * touchscreenPanAttenuator, currentDeltaY * touchscreenPanAttenuator)
            panPreviousDeltaX = ev.deltaX
            panPreviousDeltaY = ev.deltaY
        });
        hammertime.on('panend', function(ev) {
            //console.log(ev);
            //pan(ev.deltaX * touchscreenPanAttenuator, ev.deltaY * touchscreenPanAttenuator)
            panPreviousDeltaX = 0
            panPreviousDeltaY = 0
        });
        var previousPinchScale = 1
        var pinchZoomSpeed = .1
        var originalWidth = null
        var originalHeight = null
        hammertime.on('pinchstart', function(ev) {
            ev.preventDefault();
            var img = getImage()
            originalWidth = img.width
            originalHeight = img.height
            //console.log(originalWidth + " " + originalHeight)
        })
        hammertime.on('pinch', function(ev) {
            ev.preventDefault()
            //console.log(ev);
            //var currentScale = ev.scale - previousPinchScale
            //zoom(1 + currentScale)
            //previousPinchScale = ev.scale
            //zoom(ev.distance)
            /*var img = getImage()
            img.width = originalWidth * ev.scale
            img.height = originalHeight * ev.scale*/
            //console.log(ev.scale + " " + img.width + " " + img.height)
            zoom(ev.scale)
        });
        
    }

    function loadImageData(path, page, callback) {
        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            //console.log(this.responseText)
            if (this.readyState == 4 && this.status == 200) {
                var img = getImage()
                img.src = this.responseText;
                // initialize image settings / defaults
                document.imageSettings = {
                    path: path,
                    page: page,
                    width: img.width,
                    height: img.height,
                    left: num(img.style.left, 0),
                    top: num(img.style.left, 0),
                    zoom: 1.0,
                    minimumZoom: Math.min(viewportHeight() / img.height, viewportWidth() / img.width)
                }
                callback()
            }
        };
        xhttp.open("GET", "imageData?path=" + encodeURIComponent(path) + "&page=" + page, true);
        xhttp.send();
    }

</script>
</head>
<body>
    <img src="" />
    <div id="prev"></div>
    <div id="next"></div>
    <div id="top"></div>
    <div id="canv"></div>
    <script>
        

        window.onload = function() {
            //console.log(document)
            //disableEventHandlers(document)
            
            //enableTouchGestures(getImage())
            //enableTouchGestures(document.all.item(0))
            var canv = document.getElementById("canv")
            enableTouchGestures(canv)
            canv.addEventListener("wheel", mouseWheelScroll)
            canv.addEventListener("mousedown", mouseDown)
            canv.addEventListener("mouseup", mouseUp)
            canv.addEventListener("mouseout", mouseUp)
            canv.addEventListener("mousemove", mouseMove)

            loadImageData("C:\\Users\\silvi\\Dropbox\\comics\\Adventure Time\\Adventure Time (01 - 39) (ongoing) (2012-)\\Adventure Time 036 (2015) (digital) (Minutemen-InnerDemons).cbr", 10, function() {
                //console.log(document.imageSettings)
                fitPageToScreen()
            })
            
            
        }
    </script>
</body>
</html>